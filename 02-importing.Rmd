# Importing data {#import}

```{r, warning = FALSE, message = FALSE}
library(tidyverse)
library(lubridate)
library(tidyices)
```

## Data download

Download the raw data using the `getDATRAS` function from the [icesDatras](https://github.com/ices-tools-prod/icesDatras)-package and store it for later retrieval.

```{r, eval = FALSE}
# not run
yrs <- 1965:2018
qts <- c(1, 3)
hh_raw <- 
  icesDatras::getDATRAS(record = "HH", survey = "NS-IBTS", years = yrs, quarters = qts)
hl_raw <- 
  icesDatras::getDATRAS(record = "HL", survey = "NS-IBTS", years = yrs, quarters = qts)
ca_raw <- 
  icesDatras::getDATRAS(record = "CA", survey = "NS-IBTS", years = yrs, quarters = qts)
species <- tidyices::get_latin()

nsibts_raw <- list(hh = hh_raw, hl = hl_raw, ca = ca_raw, sp = species)
save(nsibts_raw, file = "data/nsibts_raw.rda")
write_rds(species, "data/species_code.rda")
```


## Data tidying

Lets load the raw data we have imported earlier:

```{r, eval = FALSE}
load("data/nsibts_raw.rda")
```


### The haul data

The haul dataframe contains one record per haul and is in a relatively tidy format. The total number of variables (61) may though be a bit overwhelming for routine abundance estimates. The function `tidy_hh` does the following:

* The unique key: The linkage to other dataframes is through the combined key of year, quarter, ship, gear and haulno. This combination of variable is unique within the haul-dataframe. In order to facilitate linkage the key variables are combined into a single variable named **id**. In the haul table the original variables are retained.
* A datetime variable: Information of the date and time of haul shot are stored in four variables: year, month, day and timeshot. These variables are combined into a single **datetime** variable.
* By default, only selected variables are returned, these being: id, year,
quarter, survey, ship, gear, haulno, date, country, depth, haulval, hauldur,
shootlat, shootlong, haullat, haullong, statrec, daynight, datatype, stdspecreccode, bycspecreccode). If all variable are wished for in further processing, the argument all_variable in the `tidy_hh`-function can be set to TRUE.


```{r, message = FALSE, warning = FALSE, eval = FALSE}
hh <-
  nsibts_raw$hh %>% 
  tidyices::tidy_hh()
```

#### Roundfish area

In this booklet one largely works with the NS-IBTS data. In some of the steps the "Roundfish area" (LINK) is used. A new numerical variable is created that contains the numerical code of the "Roundfish area" that the haul belongs to by: 
```{r, message = FALSE, warning = FALSE, eval = FALSE}
ns_area <- rgdal::readOGR("data-raw/NS_IBTS_RF.dbf", verbose = FALSE)
hh <-
  hh %>% 
  mutate(nsarea = gisland::geo_inside(shootlong, shootlat, ns_area, "AreaName") %>% as.integer())
```

We may also be interested in selecting data by ICES areas, hence:
```{r, eval = FALSE}
fao <- 
  gisland::read_sf_ftp("fao-areas_nocoastline")
library(sf)
hh <-
  hh %>% 
  mutate(faoarea = gisland::geo_inside(shootlong, shootlat, fao, "name"))
```



### The length data

The exchange format for the length related measuments is a bit messy. E.g.:

* The species depends on a numerical code (SpecCode) whose meaning then depends on another variable (SpecCodeType). Then there is a third reference to species code (Valid_Aphia).
* The unit of the variable length class (LngtClass) is different and is dependent on another variable (lngtcode).
* The most confusing part is that the number of fish "measured" (HLNoAtLngt) is different, its meaning dependent on a variable (DataType) in the haul table.
* Lastly, there are a lot of variables (27) in the raw length table, many of them really associated with the haul table and hence redundant.

A convenient functions, `tidy_hl` basically takes care of the above, it specifically doing:

* Only distinct records (they are all distinct)
* Filter out data were species code, length-code and length-class are undefined
* Set lengths to millimeter. In the raw records:
- If **lngtcode** is "1" then the **lngtclass** is in centimeters
- If **lngtcode** is "." or "0" then the **lngclass** is in millimeters
* Standardise the **haul numbers at length**. In the raw data:
- If **datatype** in the station table is "C" then **hlnoatlngt** has been standardized to 60 minutes haul
- If **datatype** in the station table is "R" then **hlnoatlngt** has not been standardized to 60 minutes haul
* Get the latin species name from the `sp`-table
* Return only variable that are needed in further processing

In order for this to complete its job, we need in addition to the raw hl-dataframe to pass the tidy haul-dataframe (because that is where the variable DataType is stored). And to convert the coded species information to latin name we need to supply the proper "lookup" table (see dataframe species below):

```{r, message = FALSE, warning = FALSE, eval = FALSE}
species <- read_rds("data/species.rda")
hl <-
  nsibts_raw$hl %>% 
  tidyices::tidy_hl(hh, species) %>% 
  select(-species)
```

So starting with the raw length dataframe containing 27 variables what is returned is a dataframe that contains only 5 variables, the haul id, the species name (latin), sex, length (in centimeters) and the number of fish measured (n).

### The age data

.. draft to be written

```{r, eval = FALSE}
ca <-
  nsibts_raw$ca %>% 
  tidyices::tidy_ca(species = species) %>% 
  select(-species)
```

### Save stuff for later use

```{r, eval = FALSE}
hh %>% write_rds("data/nsibts_hh.rds")
hl %>% write_rds("data/nsibts_hl.rds")
ca %>% write_rds("data/nsibts_ca.rds")
```

# Other surveys

```{r, eval = FALSE}
# not run
yrs <- 1987:2018
qts <- c(1:4)
hh_raw <- 
  icesDatras::getDATRAS(record = "HH", survey = "BTS", years = yrs, quarters = qts)
hl_raw <- 
  icesDatras::getDATRAS(record = "HL", survey = "BTS", years = yrs, quarters = qts)
ca_raw <- 
  icesDatras::getDATRAS(record = "CA", survey = "BTS", years = yrs, quarters = qts)
bts_raw <- list(hh = hh_raw, hl = hl_raw, ca = ca_raw)
save(bts_raw, file = "data/bts_raw.rda")
```


```{r, eval = FALSE}
load("data/bts_raw.rda")
hh <-
  bts_raw$hh %>% 
  tidyices::tidy_hh() %>% 
  mutate(nsarea = gisland::geo_inside(shootlong, shootlat, ns_area, "AreaName") %>% as.integer(),
         faoarea = gisland::geo_inside(shootlong, shootlat, fao, "name"))
hl <- 
  bts_raw$hl %>% 
  tidyices::tidy_hl(hh, species) %>% 
  select(-species)
ca <-
  bts_raw$ca %>% 
  tidyices::tidy_ca(species = species) %>% 
  select(-species)
hh %>% write_rds("data/bts_hh.rds")
hl %>% write_rds("data/bts_hl.rds")
ca %>% write_rds("data/bts_ca.rds")
```

## Get the whole mess

```{r eval = FALSE}
library(tidyverse)
library(lubridate)
library(tidyices)
library(sf)
fao <- gisland::read_sf_ftp("fao-areas_nocoastline")
ns_area <- rgdal::readOGR("data-raw/NS_IBTS_RF.dbf", verbose = FALSE)
species <- read_rds("data/species.rda")

dtrs <- icesDatras::getDatrasDataOverview()
res_hh <- res_hl <- res_ca <- list()
for(i in 1:length(dtrs)) { 
  
  sur <- names(dtrs[i])
  print(sur)
  yrs <- rownames(dtrs[[i]]) %>% as.integer()
  qts <- c(1:4)
  if(sur == "NS-IBTS") qts <- c(1, 3)
  
  
  hh_raw <- 
    icesDatras::getDATRAS(record = "HH", survey = sur, years = yrs, quarters = qts)
  hl_raw <- 
    icesDatras::getDATRAS(record = "HL", survey = sur, years = yrs, quarters = qts)
  ca_raw <- 
    icesDatras::getDATRAS(record = "CA", survey = sur, years = yrs, quarters = qts)
  list(hh = hh_raw, hl = hl_raw, ca = ca_raw) %>% 
    write_rds(path = paste0("data-raw/datras/", tolower(sur), "_raw.rds"))
  
  # tidy
  hh <-
    hh_raw %>% 
    tidyices::tidy_hh() %>% 
    mutate(nsarea = gisland::geo_inside(shootlong, shootlat, ns_area, "AreaName") %>% as.integer(),
           faoarea = gisland::geo_inside(shootlong, shootlat, fao, "name"))
  if(!is.null(hl_raw)) {
    hl <- 
      hl_raw %>% 
      tidyices::tidy_hl(hh, species) %>% 
      select(-species)
  }
  if(!is.null(ca_raw)) {
    ca <-
      ca_raw %>% 
      tidyices::tidy_ca(species = species) %>% 
      select(-species)
  }
  hh %>% write_rds(paste0("data/", tolower(sur), "_hh.rds"))
  if(!is.null(hl_raw)) hl %>% write_rds(paste0("data/", tolower(sur), "_hl.rds"))
  if(!is.null(ca_raw)) ca %>% write_rds(paste0("data/", tolower(sur), "_ca.rds"))
  
  res_hh[[i]] <- hh
  res_hl[[i]] <- hl
  res_ca[[i]] <- ca
}

res_hh %>% bind_rows() %>% write_rds("data/hh_datras.rds")
res_hl %>% bind_rows() %>% write_rds("data/hl_datras.rds")
#res_ca %>% bind_rows() %>% write_rds("data/ca_datras.rds")

```

