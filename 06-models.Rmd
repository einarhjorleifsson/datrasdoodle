# Common models {#models}

## Length weight

## von Bertalanffy

## Maturity 0give

... Something about the model

### One species

Lets start with only focusing on one species.

```{r warning = FALSE, message = FALSE}
library(tidyverse)
library(modelr)
ca <- read_rds("data/nsibts_ca.rds")
d <- 
  ca %>% 
  filter(latin == "Pleuronectes platessa") %>% 
  # CHECK: Not sure if this is correct
  mutate(mature = ifelse(maturity %in% c(1, 61), 0, 1)) %>% 
  drop_na() %>% 
  filter(sex %in% c("M", "F"))
```

An empirical fit:

```{r}
d2 <-
  d %>% 
  group_by(age) %>% 
  summarise(p = sum(mature/n()),
            n = n())

model <- glm(mature ~ age, data = d, family = binomial)

grid <-
  data_frame(age = seq_range(d$age, 20)) %>% 
  mutate(pY = predict(model, newdata = ., type = 'response'))

ggplot(d, aes(x = age)) +
  geom_point(aes(y = mature)) +
  geom_line(data = grid, aes(y = pY)) +
  geom_point(data = d2, aes(y = p), colour = "red")
  
model <- glm(mature ~ age + sex, data = d, family = binomial)

grid <-
  d %>% 
  data_grid(age, sex) %>% 
  mutate(pY = predict(model, newdata = ., type = 'response'))
# or
library(broom)
res <-
  d %>% 
  data_grid(age, sex) %>% 
  augment(x = model, newdata = ., type.predict = "response") %>% 
  as_tibble()

grid %>% 
  ggplot(aes(age, pY, colour = sex)) +
  geom_line() +
  expand_limits(y = 0)

# or just
ggplot(d, aes(age, mature, colour = sex)) + 
    geom_point() + 
    geom_smooth(method = 'glm', method.args = list(family = 'binomial')) + 
    scale_y_continuous()
```


```{r message = FALSE}
common <- c("Clupea harengus", "Sprattus sprattus", "Gadus morhua",
            "Melanogrammus aeglefinus", "Merlangius merlangus", "Pollachius virens",
            "Trisopterus esmarkii", "Scomber scombrus", "Pleuronectes platessa")
d <- 
  ca %>% 
  filter(latin %in% common) %>% 
  as_tibble() %>% 
  mutate(mature = ifelse(maturity %in% c(1, 61), 0, 1)) %>% 
  drop_na() %>% 
  filter(sex %in% c("M", "F"))


res <-
  d %>% 
  group_by(latin) %>%
  do(tidy(glm(mature ~ age, data = ., family = binomial)))
res <- 
  d %>% 
  group_by(latin) %>%
  do(fit = glm(mature ~ age, data = ., family = binomial))
res
res %>% tidy(fit)
res %>% glance(fit)
# here really want to predict using new shorter data frame

res %>% 
  augment(fit, type.predict = "response") %>% 
  filter(age <= 10) %>% 
  ggplot(aes(age, .fitted, colour = latin)) +
  geom_line(lwd = 1) +
  scale_colour_brewer(palette = "Set1") +
  scale_x_continuous(breaks = 0:10) +
  theme(legend.position = c(0.75, 0.3)) +
  expand_limits(y = 0)
```

## Stock recruitment relationship

```{r}
rby <-
  fishvice::read_separ("/net/hafkaldi/export/u2/reikn/hoski/Mackerel/HCRSimulations/2periods/",
                       "HockeyAcf00",
                       run = "HockeyEstAcf",
                       mName = "sep")$rby %>% 
  select(year, rec = r, ssb) %>% 
  filter(year < 2016) %>% 
  as_tibble() %>% 
  mutate(ssb = ssb / 1e3,
         rec = rec / 1e3)

# segreg
segreg <- function(df, a, b) {
  log(ifelse(df$ssb >= b, a * b, a * df$ssb))
}

initial <- function(df) {
    c(a = log(stats::median(df$rec/df$ssb, na.rm = TRUE)), 
      b = log(stats::median(df$ssb)),
      cv = 0)
  }

nllik <- function(param, data, model) {
  
    pred <- segreg(data, a = exp(param[1]), b = exp(param[2]))
    -1 * sum(stats::dnorm(log(data$rec), pred, exp(param[3]), log = TRUE))

}

fit <- stats::nlminb(initial(rby), objective = nllik, data = rby, model = segreg)


#segreg <- function(x) {ifelse(x >= b, a * b, a * x)}
#p <- 
#  ggplot(rby, aes(x = ssb, y = rec)) +
#  geom_point() +
#  expand_limits(x = 0, y = 0)
#b <- min(rby$ssb)
#a <- median(rby$rec)/b
#p + stat_function(fun = segreg)

x <- 
  expand.grid(b = seq(0, 5, by = 0.01),
              a = seq(1, 15, by = 0.01),
              ssb = rby$ssb) %>% 
  left_join(rby) %>% 
  mutate(pY = ifelse(ssb >= b, a * b, a * ssb),
         res = log(rec) - log(pY),
         res2 = res^2) %>% 
  group_by(a, b) %>% 
  summarise(sse = sum(res2),
            nllik = -sum(dnorm(log(rec), log(pY), sd(res), log = TRUE)))
library(viridis)
x3 <-
  x %>% 
  ungroup(a, b) %>% 
  filter(nllik == min(nllik))
sbreak <- exp(fit$par[[2]])
slope <- exp(fit$par[[1]])
x %>% 
  mutate(nllik = ifelse(nllik > 30, NA, nllik)) %>% 
  ggplot(aes(b, a, fill = nllik)) +
  geom_raster() +
  scale_fill_viridis(option = "B", direction = -1) +
  geom_vline(xintercept = sbreak) +
  geom_hline(yintercept = slope) +
  geom_point(data = x3, aes(a, b), colour = "blue")

# Following also leads to a false minimum
initial <- function(df) {
    c(a = log(stats::median(df$rec) / min(df$ssb)), 
      b = log(min(df$ssb)),
      cv = 0)
}
fit <- stats::nlminb(initial(rby), objective = nllik, data = rby, model = segreg)
sbreak <- exp(fit$par[[2]])
slope <- exp(fit$par[[1]])
x %>% 
  mutate(nllik = ifelse(nllik > 30, NA, nllik)) %>% 
  ggplot(aes(b, a, fill = nllik)) +
  geom_raster() +
  scale_fill_viridis(option = "B", direction = -1) +
  geom_vline(xintercept = sbreak) +
  geom_hline(yintercept = slope) +
  geom_point(data = x3, aes(a, b), colour = "blue")

# lets try husky
hockey <- function(df, rmax, sbreak) {
  log(ifelse(df$ssb >= rmax, rmax, rmax / sbreak * df$ssb))
}
initial <- function(df) {
    c(sbreak = log(min(df$ssb)),
      rmax = log(median(df$rec)/min(df$ssb)), 
      cv = 0)
}
fit <- stats::nlminb(initial(rby), objective = nllik, data = rby, model = hockey)
exp(fit$par)
sbreak <- exp(fit$par[[1]])
rmax   <- exp(fit$par[[2]])
x %>% 
  mutate(nllik = ifelse(nllik > 30, NA, nllik)) %>% 
  ggplot(aes(b, a, fill = nllik)) +
  geom_raster() +
  scale_fill_viridis(option = "B", direction = -1) +
  geom_vline(xintercept = sbreak) +
  geom_hline(yintercept = rmax) +
  geom_point(data = x3, aes(a, b), colour = "blue")
# problem??: the message is "false convergence (8)"

# -------------------------------------------------------------------------
# Try a smooth damper
llik <-  function (param, data, logpar = FALSE) 
{
    if (logpar) {
        pred <- Segreg(list(a = exp(param[1]), b = exp(param[2])), 
            data$ssb)
        sum(dnorm(log(data$rec), pred, exp(param[3]), log = TRUE))
    }
    else {
        pred <- Segreg(list(a = param[1], b = param[2]), data$ssb)
        sum(dnorm(log(data$rec), pred, param[3], log = TRUE))
    }
}

nllik <- function(param, ...) -1 * llik(param, ...)

SmoothDamper1 <- function(x,Roof,Floor) {
  deltax <- 0.01
  if(Roof == Floor) return(x) 
  lb  <-  1.0 - deltax/2.0
  ub <- 1.0 + deltax/2.0
  if(x <= lb* Roof & x >= ub*Floor) return(x)
  if(x >= ub*Roof) return(Roof)
  if(x <= lb*Floor) return(Floor)
  if(x <= ub*Roof && x >= lb*Roof) {
    y <-  (x - ub*Roof);
    return(Roof - 0.5/deltax/Roof*y*y)
  }
  if(x >= lb*Floor && x <= ub*Floor) {
    y <-  (x - lb*Floor);
    return(Floor +0.5/deltax/Floor*y*y)
  }
}

SmoothDamper <- function(x,Roof,Floor) {
  x1 <- x*0
  for(i in 1:length(x)) x1[i] <- SmoothDamper1(x[i],Roof,Floor)
  return(x1)
}

Segreg <- function(ab,ssb){
  pr <- ab$a*ssb
  pr <- SmoothDamper(pr,ab$b*ab$a,0)
  return(log(pr))
}

rby <-
  fishvice::read_separ("/net/hafkaldi/export/u2/reikn/hoski/Mackerel/HCRSimulations/2periods/",
                       "HockeyAcf00",
                       run = "HockeyEstAcf",
                       mName = "sep")$rby %>% 
  select(year, rec = r, ssb) %>% 
  filter(year < 2016) %>% 
  as_tibble()


ndat <- nrow(rby)
initial <- function(df) {
    c(a = log(stats::median(df$rec) / min(df$ssb)), 
      b = log(min(df$ssb)),
      cv = 0)
}
fit <- nlminb(initial(rby), nllik, data = rby, logpar = TRUE)
exp(fit$par)

rby <-
  rby %>% 
  mutate(rec = rec/1e3,
         ssb = ssb/1e3)
fit <- nlminb(initial(rby), nllik, data = rby, logpar = TRUE)
exp(fit$par)
exp(initial(rby))
# However, easy to get wrong minimum
initial <- function(df) {
    c(a = log(stats::median(df$rec/df$ssb, na.rm = TRUE)), 
      b = log(stats::median(df$ssb)),
      cv = 0)
}
fit <- nlminb(initial(rby), nllik, data = rby, logpar = TRUE)

```

