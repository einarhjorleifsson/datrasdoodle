# Auxiliary {#aux}



```{r}
library(tidyverse)
library(gisland)
```


## North sea roundfish area {#nsrf}

```{r, message = FALSE}
read_sf_ftp("NS_IBTS_RF") %>% 
  mutate(AreaName = as.integer(AreaName)) %>%
  ggplot() +
  theme_bw() +
  geom_sf(aes(fill = factor(AreaName))) +
  scale_fill_brewer(palette = "Set3") +
  labs(title = "North Sea roundfish area",
       subtitle = "Used for generation of age-length-keys",
       fill = "ALK areas") 
```


## Species code {#spcode}

In the DATRAS data the species are encoded. There are three columns associated with this identity:

* **speccode**: A integer code id for the species. The meaning of that value is dependent on the **speccodetype**.
* **speccodetype**: A single character letter: 
    - N: NODC code (EINAR: Think this is not used)
    - T: TSN code
    - W: WoRMS ApiaID code
* **valid_aphia**: An integer code for the species

It is not clear at the time of this writing what processes are when Latin names ara assigned to the above species code sweeps of variables. The approach taken here is to use the [World Registry of Marine Species](http://www.marinespecies.org) often written as acronym WoRMS. Fortunately an R-library [worrms](https://github.com/ropensci/worrms) allows us to obtain the Latin names programatically.

Here the variable valid_aphia is the primary source, but in cases that is not specified (is NA) the speccode is used if the speccodetype is "W". We refer to this variable as aphia. Each numerical aphia value should have a unique Latin name. For convenience a complete lookup-table is generated based on the all the DATRAS data (as available in July 2018). The following code was used:

```{r eval = FALSE}
# List the available raw survey data files
fil <- dir("data-raw/datras", full.names = TRUE)
# Collate the aphia species code list, compiled from all available surveys
SP <- list()
for(i in 1:length(fil)) {       # loop through surveys
  x <-  read_rds(fil[i])$hl
  if(!is.null(x)) {
    SP[[i]] <-
      x %>%
      select(speccodetype = SpecCodeType,
             speccode = SpecCode,
             valid_aphia = Valid_Aphia) %>%
      distinct() %>%
      as_tibble()
  }
}

# Generate a vector of aphia code
APHIA <-
  bind_rows(SP) %>%
  distinct() %>%
  mutate(id = 1:n()) %>% 
  mutate(aphia = valid_aphia) %>%
  # if valid_aphia is NA then use speccode if speccodetype is W
  mutate(aphia = ifelse(is.na(aphia) & speccodetype == "W",
                        speccode,
                        aphia)) %>% 
  select(aphia) %>% 
  drop_na() %>% 
  # return a vector
  pull(aphia) %>% 
  unique() %>% 
  sort()
# Obtain a dataframe matching aphia with Latin name
from_worms <- 
  # You need an internet connection for this to work
  wm_id2name_(id = APHIA) %>% 
  bind_rows() %>%
  gather(aphia, latin, convert = TRUE)
from_worms %>% 
  write_rds("data/species_worms.rds")
```


## What is the meaning of each specval code?

* **specval**: validity codes
    -  0	 Invalid information
    -  1	 Valid information for use in DATRAS data products
    -  2	 Partly valid information
    -  3	 Length composition incomplete
    -  4	 No length measurements only total number
    -  5	 Observed only  not measured  not counted  but only presence/absence is registered
    -  6	 No length measurements  only category catch weight
    -  7	 No length measurements  only total number and category catch weight
    -  8	 Only volume (litre) registered
    -  9	 Valid information available but not recorded in the file
    - 10	 No category catch weight  only total numbers and length composition
